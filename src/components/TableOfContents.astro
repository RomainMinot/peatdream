---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

// Filter to only show H2 and H3 headings
const filteredHeadings = headings.filter((h) => h.depth <= 3);
---

{
  filteredHeadings.length > 0 && (
    <aside class="hidden xl:block">
      <nav class="sticky top-24 max-h-[calc(100vh-8rem)] overflow-y-auto">
        <h2 class="text-lg font-semibold text-accent mb-4">Sur cette page</h2>
        <ul class="space-y-2 text-sm border-l-2 border-accent-200">
          {filteredHeadings.map((heading) => (
            <li class={heading.depth === 2 ? 'ml-0' : 'ml-4'}>
              <a
                href={`#${heading.slug}`}
                class={`block py-1 px-3 text-gray-600 hover:text-peat-600 hover:bg-peat-50 rounded transition-colors ${
                  heading.depth === 2 ? 'font-medium' : ''
                }`}>
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </nav>
    </aside>
  )
}

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const toc = document.querySelector('aside nav');
    if (!toc) return;

    const headings = Array.from(
      document.querySelectorAll('article h2[id], article h3[id]'),
    ) as HTMLElement[];

    if (headings.length === 0) return;

    const tocLinks = new Map<string, HTMLAnchorElement>();
    toc.querySelectorAll('a[href^="#"]').forEach((link) => {
      const id = link.getAttribute('href')?.slice(1);
      if (id) tocLinks.set(id, link as HTMLAnchorElement);
    });

    // Track which headings are currently visible
    const visibleHeadings = new Set<string>();

    function updateActiveHeading() {
      // Find the topmost visible heading
      let activeId: string | null = null;

      // Find first visible heading in document order
      for (const heading of headings) {
        if (visibleHeadings.has(heading.id)) {
          activeId = heading.id;
          break;
        }
      }

      // Update TOC highlight
      tocLinks.forEach((link, id) => {
        if (id === activeId) {
          link.classList.add('text-peat-600', 'bg-peat-50', 'font-semibold');
          // Scroll TOC to keep active item visible
          link.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
          });
        } else {
          link.classList.remove('text-peat-600', 'bg-peat-50', 'font-semibold');
        }
      });
    }

    // Create IntersectionObserver with proper configuration
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const id = entry.target.id;

          // Update visibility tracking
          if (entry.isIntersecting) {
            visibleHeadings.add(id);
          } else {
            visibleHeadings.delete(id);
          }
        });

        // Update the active heading after all entries are processed
        updateActiveHeading();
      },
      {
        // Trigger when heading crosses these boundaries
        // Top margin accounts for fixed header (120px)
        rootMargin: '-120px 0px -75% 0px',
        // Multiple thresholds for better precision
        threshold: [0, 0.25, 0.5, 0.75, 1],
      },
    );

    // Observe all headings
    headings.forEach((heading) => {
      observer.observe(heading);
    });

    // Smooth scroll when clicking TOC links
    tocLinks.forEach((link, id) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const heading = document.getElementById(id);
        if (heading) {
          // Calculate position accounting for fixed header
          const top = heading.getBoundingClientRect().top + window.scrollY - 100;
          window.scrollTo({
            top,
            behavior: 'smooth',
          });

          // Manually trigger update after a short delay for smooth scroll
          setTimeout(() => {
            visibleHeadings.clear();
            visibleHeadings.add(id);
            updateActiveHeading();
          }, 100);
        }
      });
    });

    // Initial check for visible headings
    setTimeout(() => {
      headings.forEach((heading) => {
        const rect = heading.getBoundingClientRect();
        // Check if heading is in the viewport accounting for header
        if (rect.top >= 100 && rect.top <= window.innerHeight * 0.3) {
          visibleHeadings.add(heading.id);
        }
      });
      updateActiveHeading();
    }, 100);
  });
</script>
