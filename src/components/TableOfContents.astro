---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

// Filter to only show H2 and H3 headings
const filteredHeadings = headings.filter((h) => h.depth <= 3);
---

{
  filteredHeadings.length > 0 && (
    <aside class="hidden xl:block">
      <nav class="sticky top-24 max-h-[calc(100vh-8rem)] overflow-y-auto pr-2">
        <div class="mb-4 pb-3 border-b border-accent-200">
          <h2 class="text-lg font-semibold text-accent flex items-center gap-2">
            <svg
              class="w-5 h-5 text-peat-600"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 6h16M4 12h16M4 18h7"
              />
            </svg>
            Sur cette page
          </h2>
        </div>
        <ul class="space-y-1 text-sm relative">
          <div class="absolute left-0 top-0 bottom-0 w-0.5 bg-accent-200" />
          {filteredHeadings.map((heading) => (
            <li class={heading.depth === 2 ? 'ml-0' : 'ml-4'}>
              <a
                href={`#${heading.slug}`}
                class={`block py-2 px-3 pl-4 text-gray-600 hover:text-peat-600 hover:bg-peat-50 rounded-r transition-all duration-200 relative ${
                  heading.depth === 2 ? 'font-medium' : ''
                }`}>
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </nav>
    </aside>
  )
}

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const toc = document.querySelector('aside nav');
    if (!toc) return;

    // Get all headings from the article
    const headings = Array.from(
      document.querySelectorAll('article h2[id], article h3[id]'),
    ) as HTMLElement[];

    if (headings.length === 0) return;

    // Create a map of TOC links
    const tocLinks = new Map<string, HTMLAnchorElement>();
    toc.querySelectorAll('a[href^="#"]').forEach((link) => {
      const id = link.getAttribute('href')?.slice(1);
      if (id) tocLinks.set(id, link as HTMLAnchorElement);
    });

    let activeId: string | null = null;
    let ticking = false;

    // Offset for the fixed header (in pixels)
    const HEADER_OFFSET = 140;

    /**
     * Find which heading is currently active based on scroll position
     */
    function findActiveHeading(): string | null {
      // Get current scroll position
      const scrollY = window.scrollY;
      const viewportMiddle = scrollY + HEADER_OFFSET + 50;

      // Find the heading that is closest to the top of the viewport
      // but still above the middle of the viewport
      let currentId: string | null = null;
      let closestDistance = Infinity;

      for (const heading of headings) {
        const rect = heading.getBoundingClientRect();
        const headingTop = rect.top + scrollY;

        // Distance from heading to our reference point
        const distance = Math.abs(headingTop - viewportMiddle);

        // If this heading is above our reference point and closer than previous
        if (headingTop <= viewportMiddle && distance < closestDistance) {
          closestDistance = distance;
          currentId = heading.id;
        }
      }

      // If we're at the very top, use the first heading
      if (!currentId && scrollY < HEADER_OFFSET + 100) {
        currentId = headings[0]?.id || null;
      }

      return currentId;
    }

    /**
     * Update the active state in the TOC
     */
    function updateTOC() {
      const newActiveId = findActiveHeading();

      // Only update if the active heading has changed
      if (newActiveId !== activeId) {
        activeId = newActiveId;

        // Remove active class from all links
        tocLinks.forEach((link) => {
          link.classList.remove(
            'text-peat-600',
            'bg-peat-50',
            'font-semibold',
            'border-l-3',
            'border-peat-600',
            '-ml-px',
          );
          link.classList.add('text-gray-600');
        });

        // Add active class to the current link
        if (activeId && tocLinks.has(activeId)) {
          const activeLink = tocLinks.get(activeId);
          if (activeLink) {
            activeLink.classList.remove('text-gray-600');
            activeLink.classList.add(
              'text-peat-600',
              'bg-peat-50',
              'font-semibold',
              'border-l-3',
              'border-peat-600',
              '-ml-px',
            );

            // Scroll the TOC to keep active item visible
            const nav = activeLink.closest('nav');
            if (nav) {
              const linkRect = activeLink.getBoundingClientRect();
              const navRect = nav.getBoundingClientRect();

              // Check if link is outside visible area
              if (linkRect.top < navRect.top || linkRect.bottom > navRect.bottom) {
                activeLink.scrollIntoView({
                  behavior: 'smooth',
                  block: 'nearest',
                });
              }
            }
          }
        }
      }

      ticking = false;
    }

    /**
     * Request an update on scroll (throttled with requestAnimationFrame)
     */
    function requestTOCUpdate() {
      if (!ticking) {
        window.requestAnimationFrame(updateTOC);
        ticking = true;
      }
    }

    // Listen to scroll events
    window.addEventListener('scroll', requestTOCUpdate, { passive: true });
    window.addEventListener('resize', requestTOCUpdate, { passive: true });

    // Handle TOC link clicks
    tocLinks.forEach((link, id) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const heading = document.getElementById(id);
        if (heading) {
          // Calculate exact position accounting for fixed header
          const top = heading.getBoundingClientRect().top + window.scrollY - HEADER_OFFSET + 20;

          window.scrollTo({
            top,
            behavior: 'smooth',
          });

          // Update immediately
          setTimeout(() => {
            activeId = id;
            updateTOC();
          }, 50);
        }
      });
    });

    // Initial update
    setTimeout(updateTOC, 100);
  });
</script>
